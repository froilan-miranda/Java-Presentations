<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Java Interfaces</title>

		<meta name="Week 1 presentation on Java operators">
		<meta name="author" content="Froilan Miranda">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

			
				<section><!------------------------------------slide---------------------------------------------->
					<h1>Java Interfaces</h1>
					<p>
						<small>Created by <a href="http://www.zipcoder.io">Froilan Miranda</a></small>
					</p>
				</section>

			
				<section><!------------------------------------slide--------------------------------------------- -->
					<h3>Interfaces</h3>
					<p>
						Interfaces and abstract classes provide more structured way to separate interface from implementation.
					</p>
				</section>
				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Abstract methods</h3>
						<p>
							This is a method that is incomplete; it has only a declaration and no method body. Here is the syntax for an abstract method declaration.
						</p>
							<pre><code data-trim>
abstract void f( );
							</code></pre>
					</section>

					<section>
						<h3>Abstract classes</h3>
						<p>
							A class containing abstract methods is called an abstract class. If a class contains one or more abstract methods, the class itself must be qualified as abstract. (Otherwise, the compiler gives you an error message.)
						</p>
					</section>

					<section>
						<img src="./images/instruments.png">
					</section>
				</section>

				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Interfaces</h3>
						<p>
							The <b>interface</b> keyword takes the concept of abstractness one step further.
						</p>
					</section>

					<section>
						<h3>Interfaces</h3>
						<p>
							The <b>abstract</b> keyword allows you to create one or more undefined methods in a class—you provide part of the interface without providing a corresponding implementation. The implementation is provided by inheritors.
						</p>
					</section>

					<section>
						<h3>Interfaces</h3>
						<p>
							The <b>interface</b> keyword produces a completely abstract class, one that provides no implementation at all. It allows the creator to determine method names, argument lists, and return types, but no method bodies. An interface provides only a form, but no implementation.
						</p>
					</section>

					<section>
						<h3>Interfaces</h3>
						<p>
							An interface says, "All classes that implement this particular interface will look like this. "Thus, any code that uses a particular interface knows what methods might be called for that interface, and that’s all. So the interface is used to establish a "protocol" between classes.
						</p>
					</section>

					<section>
						<h3>Interfaces</h3>
						<p>
							However, an interface is more than just an abstract class taken to the extreme, since it allows you to perform a variation of "multiple inheritance" by creating a class that can be upcast to more than one base type.
						</p>
					</section>
				</section>

				<section><!------------------------------------slide--------------------------------------------- -->
						<h3>Complete decoupling</h3>
						<p>
							Whenever a method works with a class instead of an interface, you are limited to using that class or its subclasses. If you would like to apply the method to a class that isn’t in that hierarchy, you’re out of luck. An interface relaxes this constraint considerably. As a result, it allows you to write more reusable code.
						</p>
				</section>

				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>“Multiple inheritance” in Java</h3>
						<p>
							Because an interface has no implementation at all—that is, there is no storage associated with an interface—there’s nothing to prevent many interfaces from being combined.
						</p>
					</section>
					<section>
						<h3>“Multiple inheritance” in Java</h3>
						<p>
							You place all the interface names after the <b>implements</b> keyword and separate them with commas.You can have as many interfaces as you want. You can upcast to each interface, because each interface is an independent type.
						</p>
					</section>
				</section>

				<section><!------------------------------------slide--------------------------------------------- -->
						<h3>Extending an interface with inheritance</h3>
						<p>
							You can easily add new method declarations to an interface by using inheritance, and you can also combine several interfaces into a new interface with inheritance.
						</p>
				</section>
				
				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Name collisions when combining Interfaces</h3>
						<p>
							You can encounter a small pitfall when implementing multiple interfaces.
						</p>
					</section>
					<section>
						<h3>Name collisions when combining Interfaces</h3>
						<p>
							The difficulty occurs because overriding, implementation, and overloading get unpleasantly mixed together. Also, overloaded methods cannot differ only by return type. 
						</p>
					</section>
				</section>

				
				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Adapting to an interface</h3>
						<p>
							One of the most compelling reasons for interfaces is to allow multiple implementations for the same interface.
						</p>
					</section>
					<section>
						<h3>Adapting to an interface</h3>
						<p>
							You write a method that performs certain operations, and that method takes an interface that you also specify. You’re basically saying, "You can use my method with any object you like, as long as your object conforms to my interface." This makes your method more flexible, general and reusable.
						</p>
					</section>
				</section>

				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Fields in interfaces</h3>
						<p>
							Because any fields you put into an interface are automatically static and final, the interface is a convenient tool for creating groups of constant values.
						</p>
					</section>
					<section>
						<h3>Fields in interfaces</h3>

						<pre><code data-trim>
// Using interfaces to create groups of constants.
package interfaces;
public interface Months {
  int
    JANUARY = 1, FEBRUARY = 2, MARCH = 3,
    APRIL = 4, MAY = 5, JUNE = 6, JULY = 7,
    AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,
    NOVEMBER = 11, DECEMBER = 12} ///:~
    					</code></pre>
					</section>
				</section>
				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Initializing fields in interfaces</h3>
						<p>
							Fields defined in interfaces cannot be "blank finals," but they can be initialized with non- constant expressions.
						</p>
					</section>
					<section>
						<h3>Initializing fields in interfaces</h3>

						<pre><code data-trim>
// Initializing interface fields with
// non-constant initializers.
import java.util.*;
public interface RandVals {
  Random RAND = new Random(47);
  int RANDOM_INT = RAND.nextInt(10);
  long RANDOM_LONG = RAND.nextLong() * 10;
  float RANDOM_FLOAT = RAND.nextLong() * 10;
  double RANDOM_DOUBLE = RAND.nextDouble() * 10;
} ///:~
    					</code></pre>
					</section>
				</section>

				
				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Nesting interfaces</h3>
						<p>
							Interfaces may be nested within classes and within other interfaces.
						</p>
					</section>
					<section>
						<h3>Nesting interfaces</h3>
						<p>
							Implementing a private interface is a way to force the definition of the methods in that interface without adding any type information (that is, without allowing any upcasting).
						</p>
					</section>
					<section>
						<h3>Nesting interfaces</h3>
						<p>
							Interface nested within another interface is automatically public and cannot be made private.
						</p>
					</section>

					<section>
						<h3>Nesting interfaces</h3>
						<p>
							When you implement an interface, you are not required to implement any interfaces nested within. 
						</p>
					</section>

				</section>
				<section><!------------------------------------slide--------------------------------------------- -->
					<section>
						<h3>Interfaces and factories</h3>
						<p>
							An interface is intended to be a gateway to multiple implementations, and a typical way to produce objects that fit the interface is the Factory Method design pattern. Instead of calling a constructor directly, you call a creation method on a factory object which produces an implementation of the interface—this way, in theory, your code is completely isolated from the implementation of the interface, thus making it possible to transparently swap one implementation for another.
						</p>
					</section>
				</section>





			</div><!-- slides -->
		</div><!-- reveal -->

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
